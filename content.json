{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"个人的一个笔记存放点","link":"/about/index.html"}],"posts":[{"title":"哲学","text":"超兽武装夜凌云 强者战胜弱者本就是天道，我并不想逆天而行，如果没有强者的统治，这个世界将是一片混乱 善恶不分？这个世界有善恶吗？那我问你，什么是善，什么是恶？在我看来是善的东西，在你们看来就是恶的，这个世界根本就没有绝对的善恶，就算有！也是强者通过武力，来向弱者证明的 我们最大的敌人其实就是我们自己，强就是弱，弱就是强，你越强其实就越危险，因为所有人都会对付你，都会留意你，包括站在你对面的敌人，和站在你身后的自己人！ 你如果想击倒一个人最好的办法，就是让他自己心里觉得恐惧，那么用不着你出手，他自己就先将自己击倒。 我们飞翔得越高我们在那些不能飞翔的人的眼中就越是渺小。 冥王 当你有爱去保护羊群，那么对于狼这种爱心就是毁灭，因为它们会因此而活活饿死 这个世界本就如此，不是狼死就是羊死，不是弱小的狼被饿死，就是弱小的羊被咬死 或许这世界太过残酷，然而却因此而美丽！ 自从厌倦于追寻，我已学会一觅即中，自从一股逆风袭来，我已能抗御八面来风，驾舟而行。 在天堂和地狱之间没有我们选择的权利，只有我们被选择的命运。 我的内心就像树一样，树越是向往高处的光亮，它的根就越要向下，向泥土，向黑暗的深处。 当我到达高处，便发觉自己总是孤独的，无人同我说话，孤寂的严冬令我发抖，我在高处究竟意欲何为。 美，只不过是一瞬间的感觉，只有真实才是永恒的，而真实绝不会美！ 鲸 鲨 王 人的欲望，就如同高山滚石一般，一旦开始，就再也停不下来了。除非这些石头原本就在山谷的底部。 获得自由的代价总是昂贵的，总是要经历无数的战争，无数的牺牲才可以换取的。 这世界上有一种人（奴隶）虽然是人，但他们从来就没有过过属于自己的生活，他们的一切都遵照他人的意思而活，这种人千古以前就有，千古以后还是不会消失，这种人永远都得不到自由，因为他们的心灵早就被枷锁（奴性）禁锢了。 苗条俊 这个世界、强弱可以互换，黑白可以颠倒，族群间的实力也会此消佊长 所以和平只能是短暂的，我们的敌人和朋友，也都是短暂的，这个世界根本不可能实现永恒和平 但正因为如此，世界也才需要我们超兽战士，我们超兽战士使命就是维持宇宙间的平衡 玄易子 已有的事，后必再有，已行的事，后必再行。 人类对自己不懂的事情总会觉得有些害怕 雪皇 爱和恨最大的不同，能使人对未来充满希望，而恨却只能让人想到过去那些痛苦的往事 爱与恨在一念之间，而你心中的仇恨，已经蒙蔽了你的双眼 仇恨的意义：1. 会让一个单纯的人变得复杂1. 他会让人学会在现实的社会中生存1. 会使人变得更强大，不再被欺负1. 激发人更想要活下去的欲望 龙莹 天地本就无情，若见有情，天早已荒，地早已老","link":"/2022/03/10/%E5%93%B2%E5%AD%A6/"},{"title":"文本三剑客-AWK-详解","text":"AWK基础应用一、Awk简介awk是一门编程语言同时也是数据处理引擎 创造者：Aho、Weinberger、Kernighan 基于模式匹配检查输入文本，逐行处理并输出 通常用在Shell脚本中，获取指定的数据 单独用时，可对文本数据做统计 二、命令格式解析格式11、awk [选项] ‘[条件]{编辑指令} ‘ 文件… 2、举例说明 12345awk -F&quot;:&quot; '{print $1,$3}' /etc/passwd |head -3root 0daemon 1bin 2 格式21、前置命令 | awk [选项] ‘[条件]{编辑指令}’ 1cat /etc/passwd | awk 'pattern{commands}'' 2、举例说明 1234cat /etc/shadow | awk -F&quot;:&quot; '{print $1,$2}' |head -3root !daemon *bin * 五、Awk常用选项 选项 用途 -f 指定一个awk脚本 -F 指定分隔符 -v 传递变量 -V 查看版本信息 三、AWK变量内置变量 变量 用途 $0 整行内容 $1-$n 当前行的第1-n个字段 NF (Number Field) 当前行的字段个数,也就是有多少列 NR (Number Row) 当前行的行号,从1开始 FNR 当文件处理时,每个文件行号单独计数 FS (File Separator) 输出字段分隔符。不指定默认以空格或者tab分割 RS (Row Separator) 输入行分隔符。默认回车 OFS 输出字段分隔符。默认空格 ORS 输出行分隔符。默认为回车 FILENAME 当前输入的文件名字 ARGC 当前命令行参数个数 ARGV 当前命令行参数数组 RS、FS、ORS 、OFS1.phone文件里面 123cat phone匪警|110-火警|119-急救中心|120-交通故障|122-天气预报|12121 2.指定输入行的分隔符 1234567cat phone |awk 'BEGIN{RS=&quot;-&quot;;FS=&quot;|&quot;}{print $1&quot;_&quot;$2}END{}'匪警_110火警_119急救中心_120交通故障_122天气预报_12121 3.指定输出行 1234cat phone |awk 'BEGIN{RS=&quot;-&quot;;FS=&quot;|&quot;;ORS=&quot;&amp;&quot;}{print $1&quot;_&quot;$2}END{}'匪警_110&amp;火警_119&amp;急救中心_120&amp;交通故障_122&amp;天气预报_12121 4.字段间的分隔符，print之间用逗号隔开 123cat phone |awk 'BEGIN{RS=&quot;-&quot;;FS=&quot;|&quot;;ORS=&quot;&amp;&quot;;OFS=&quot;_&quot;}{print $1,$2}END{}'匪警_110&amp;火警_119&amp;急救中心_120&amp;交通故障_122&amp;天气预报_12121 ARGC1.这里输出结果是3，awk本身算一个，文件名各算一个 123awk '{print ARGC}'' /etc/passwd /etc/shadow3 NR、FNR、FILENAME、NF1.统计/etc/shadow有多少行 123awk '{print FNR}' /etc/passwd41 2.统计/etc/passwd /etc/group两个连续文件的里面的行数 如果使用FNR发现统计的是各自文件的行数 1awk '{print FNR}' /etc/passwd /etc/group 使用NR就可以将多个文件行数累计起来 1awk '{print NR}' /etc/passwd /etc/group 3.把一个文件按–&gt;行号：文件名–&gt;此行内容 这种格式输出 4.统计每行有多少个字段 自定义变量引入 刚刚学的我们知道，awk调用内置变量时，不需要在前面加$符号。 那怎么调用系统shell的变量呢? 我现在来试试，变量前面不加$，结果是输出为空行 一个$是输出当前行的所有内容，那这里是在title前添加$会输出怎样的结果呢？ 加了其它的任意字符也是可以的，说明$后跟任意非具有特定意义的字符会当$0使用 3.回到刚才的问题，那如何引用外部的shell变量呢? 方式一1.可以使用-v参数 格式：变量名=$shell的变量名 多个用变量,隔开 方式二1.先设置成全局变量，然后用awk的ENVIRON数组引用它 举例1.输出当前登录用户在password中的记录，print后面可以什么都不加,默认就是$0 2.输出用户yoyo在/etc/shadow中的密码记录 四、AWK处理动作动作类型行前处理：BEGIN{} 读入第行文本之前执行 一般用来初始化操作 逐行处理：{} 逐行读入文本执行相应的处理 是最常见的编辑指令块 在所有行后处理：END{} 处理完最后一行文件之后执行 一般用来输出处理结果 类型小结 动作 作用 BEGIN{} 行前处理 {} 逐行处理 END{} 行后处理 这3个动作，它们可以单独使用也可以同时一起使用 举例说明1.预处理不需要数据文件 123awk 'BEGIN{a=99;print a+1}'100 2.统计使用bash的用户个数 123awk 'BEGIN{x=0}/bash$/{x++}END{print x}' /etc/passwd3 3.预处理时，行数为0，全部处理完以后，行数为已读入文本的行数 1234awk 'BEGIN{print NR}END{print NR}' /etc/passwd041 六、格式化输出格式说明 %s 打印字符串 %d 打印十进制数 %f 打印浮点数 %x 打印十六进制数 %o 打印八进制数 %e 打印数字的科学计数法形式 %c 打印单个字符的ASCII码 修饰字符 - 左对齐 + 右对齐 # 在8进制前面显示0，16进制前面显示0x 举例使用输出/etc/passwd下用户名与十六进制的UID 格式：printf “%d,%\\#x…”,参数1.参数n.. 1awk -F: '{printf &quot;%-20s %-#x\\n&quot;,$1,$3 }' /etc/passwd|head -3 输出结果： 123root 0daemon 0x1bin 0x2 七、AWK处理条件处理条件概述所有的行全部处理并输出吗？ 怎么限制处理的条件？ 根据多个条件来处理指定的行？ 条件表现形式格式回顾 awk [选项] ‘[条件]{编辑指令}’ 文件… 条件的表现形式？ 正则表达式 数值/字符串比较 逻辑比较 运算符 正则表达式语法： /正则表达式/ ~ 匹配、! ~不匹配 1.匹配/etc/passwd文件行中含有以ro开头的用户记录 1awk -F&quot;:&quot; '/^ro/{print}' /etc/passwd 2.列出第7个字段不以bash结尾的用户名、登录shell 1awk -F&quot;:&quot; '$7!~/bash$/{printf &quot;%-20s %s\\n&quot;,$1,$7}' /etc/passwd 运算符匹配关系运算符 符号 说明 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 == 等于 != 不等于 ~ 匹配正则表达式 !~ 不匹配正则表达式 1.输出第2行用户记录 1awk 'NR==2{print}' /etc/passwd 2.输出第2列不是x的用户记录，可以用它来判断空密码 1awk -F&quot;:&quot; '$2!=&quot;x&quot;' /etc/passwd 逻辑运算符 符号 说明 &amp;&amp; 与 || 或 ! 非 1.输出系统中uid小于100的用户 1awk -F&quot;:&quot; '$3&lt;100{printf &quot;%-10s%s\\n&quot;,$1,$3}' /etc/passwd 2.输出系统中长度大于3位小于5位的用户名，并且uid是2位数的 1awk -F&quot;:&quot; '$1~/^[a-zA-Z]{3,5}$/ &amp;&amp; $3&lt;100 {print}' /etc/passwd 3.输出系统中uid大于等于50并且此用户可以登录系统 1awk -F&quot;:&quot; '$3&gt;=50 &amp;&amp; !/nologin$/{printf &quot;%-10s %s\\n&quot;,$1,$3}' /etc/passwd 变量的运算运算符号 符号 说明 + 加 - 减 * 乘 / 除 % 取余 ^或** 乘方 ++x 先自增1 x++ 后自增1 举例练习1.计算/var/log/message中的空白行的数量 1awk 'BEGIN{x=0}/^$/{x++}END{printf &quot;空白行数量:%d\\n&quot;,x}' /var/log/messages 2.算出它们的平均分,并且从小到大进行排序 1)、grade.txt文件内容 喜羊羊 80 90 100 96 路飞 11 12 13 14 鸣人 30 60 90 66 沧桑 99 66 33 100 小朋友 6 5 4 3 暖羊羊 50 30 60 70 灰太狼 100 99 98 100 2)、编写awk命令 123456awk 'BEGIN{FS=&quot; &quot;;print &quot;姓名\\t计算机\\t物理\\t天文\\t地理\\t平均分&quot;}{avg=($2+$3+$4)/4;printf &quot;%-3s\\t %s \\t%s \\t%s \\t%s \\t%.2f\\n&quot;,$1,$2,$3,$4,$5,avg}' grade.txt | sort -k6 -n 3)、运行结果 4）、算出它们所有学科的总成绩 1234567891011121314151617awk 'BEGIN{ FS=&quot; &quot;; print &quot;姓名\\t天文\\t地理\\t军事\\t物理\\t总分&quot;}{ sum=$2+$3+$4+$5 s_Sum+=sum s_Astronomy+=$2 s_Geography+=$3 s_Military+=$4 s_Physical+=$5 printf &quot;%s\\t %s\\t %s\\t %s\\t %s\\t %s\\t\\n&quot;,$1,$2,$3,$4,$5,sum}END{ print &quot;---------------------------------------------&quot; printf &quot;总和\\t %d\\t %d\\t %d\\t %d\\t %d\\t\\n&quot;,s_Astronomy,s_Geography,s_Military,s_Physical,s_Sum}' grade.txt | sort -k6 -n 5)、运行结果 AWK高级应用一、流程控制条件语句语法格式单分支 123if(条件){ 动作} 双分支 123456if(条件){ 动作1}else{ 动作2} 多分支 12345678910if(条件表达式){ 动作1}else if(条件表达式){ 动作2}...else{ 动作N} 举例应用1.找出系统用户中uid 50 &gt; uid &gt; 100并且用户名的长度小于等于5 1awk -F&quot;:&quot; '$1~/^.{1,5}$/{if ($3 &gt;50 &amp;&amp; $3 &lt;100)print }' /etc/passwd 循环语句while 循环语法格式： 1234while(条件表达式){ 动作} 举例应用： 1.从1累加到100 123456789BEGIN{ i=1;sum=0; while(i&lt;=100) { sum+=i; i++; } print sum;} 2.统计/etc/passwd文件内root出现的次数 利用-F [:/]，表示分隔符为:或者/ 1awk -F &quot;[:/]&quot; '{i=1}{ while(i&lt;NF){ if($i~/root/){j++};i++ } }END{print j}' /etc/passwd 3.此操作等效上述操作 12str=$(cat /etc/passwd)echo $str | awk -F &quot;root&quot; '{print NF-1}' do while循环语法格式： 123do{ 动作} while(条件表达式) 举例应用： 12345678910awk 'BEGIN{ i=1; sum=0; do { sum+=i; i++; } while(i&lt;=100); print sum}' for循环语法格式： 1234for(初始化计数器;计数器测试;计数器变更){ 动作} 举例应用： 12345678awk 'BEGIN{ sum=0; for(i=1;i&lt;=100;i++) { sum+=i; } print sum}' 其他控制语句常用的中断、退出等awk指令 关键字 含义 break 结束当前的循环体 continue 中止本次循环，转入下一次循环 next 跳过当前行，读入下一行文本开始处理 exit 结束文本读入，转入END{}执行如果没有END{}则直接退出awk处理操作 1.输出奇数行的用户记录 1awk -F&quot;:&quot; 'NR%2==0{next}{printf &quot;%-10d %s\\n&quot;,NR,$1}' /etc/passwd 2.从1~100偶数相加的和 1awk 'BEGIN{sum=0;for(i=1;i&lt;=100;i++){ if (i%2==0)continue; sum+=i;} print sum}' 二、Awk数组定义数组 格式：数组名[下标] = 元素值 1.定义索引数组 12345678910awk 'BEGIN{ array[0]=&quot;haha&quot;; array[1]=&quot;lala&quot;; array[2]=&quot;yaya&quot;; # 遍历数组 for(key in array) { print key,array[key] }}' 2.定义关联数组 1234567891011awk 'BEGIN{ array[&quot;blue&quot;]=&quot;sky&quot;; array[&quot;red&quot;]=&quot;hat&quot;; array[&quot;green&quot;]=&quot;grass&quot;; #遍历数组 for(key in array) { print key,array[key] }}' 使用数组 格式：数组名[下标] 遍历数组 用法：for(变量 in 数组名){print 数组名[变量]} 举例使用1.去除文件中重复的行 1awk '!a[$0]++' /etc/profile a[$0]++ 第1次就是0，0是假，取反后就是真，默认就会输出 第2次的时候已经变成1了，1取反就成了假，所以就不会再输出 2.列出/etc/passwd中的登录shell种类 1234567awk -F&quot;:&quot; '!a[$7]++{print $7}' /etc/passwd/bin/bash/sbin/nologin/bin/sync/sbin/shutdown/sbin/halt 综合案例1.自动生成日志脚本 1234567891011121314151617#!/bin/bashINDEX=1echo &quot;按CTRL+C停止生成&quot;while :do for user in &quot;喜羊羊&quot; &quot;懒羊羊&quot; &quot;沸羊羊&quot; &quot;慢羊羊&quot; &quot;灰太狼&quot; &quot;武大郎&quot; do COUNT=$RANDOM IN_NUM=$[RANDOM%999] FAIL_NUM=$[COUNT-IN_NUM] echo &quot;`date '+%Y-%m-%d %H:%M:%S'` $INDEX 处理人:$user insert $COUNT records into database:product table:detail, insert $IN_NUM records successfully,failed $FAIL_NUM records&quot; &gt;&gt; ./db.log.`date +%Y%m%d` let INDEX++ donedone 2.生成结果示例 3.编写一个log.awk脚本统计出每个用户查询的记录数，成功与失败的数量 1234567891011121314151617181920BEGIN{print &quot;用户\\t记录数\\t成功\\t失败\\t&quot;}{ split($4,arr,&quot;:&quot;); user=arr[2]; total=$6; ok=$12; no=$15; users[user][&quot;total&quot;]+=total; users[user][&quot;ok&quot;]+=ok; users[user][&quot;no&quot;]+=no;}END{ for(u in users) { printf &quot;%s\\t%d\\t%d\\t%d\\n&quot;,u,users[u][&quot;total&quot;],users[u][&quot;ok&quot;],users[u][&quot;no&quot;] }} 4.运行结果","link":"/2022/03/20/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2-AWK/"},{"title":"文本三剑客-AWK-练习","text":"AWK—练习基础1、提取本机的IP地址 1ifconfig |grep inet | awk '{print $2}' 2、提取根分区使用率 方法1： 1df -hT / | sed -n '$p' |awk '{print $6}' 方法2： 1df -hT | awk '$7~/^\\/$/{print $6}' 3、格式化输出/etc/passwd文件 只显示用户名、UID、宿主目录3列 给每列加标题，最后输出处理的总行数 1234cat /etc/passwd |awk -F&quot;:&quot; 'BEGIN { printf &quot;%-20s %-6s %-20s\\n&quot;,&quot;USER&quot;,&quot;UID&quot;,&quot;HOME&quot; } {printf &quot;%-20s %-6s %-20s\\n&quot;,$1,$3,$6} END{print &quot;total line:&quot;,NR}' 4.列出UID间于901~905的用户详细信息 5.找出UID与GID不同的用户，列出用户名及对应的UID、GID。 6.输出/etc/hosts文件内以127或192开头的记录 7.列出100以内整数中7的倍数或是含7的数 12seq 100 | awk 'NR % 7 == 0 || NR~/7/' seq 100 | awk '$0 % 7 == 0 || $0~/7/' 9.统计/etc/passwd文件中各种shell出现的次数 进阶1.编写getpwd.sh脚本的任务要求如下： 分析出使用bash/sh/zsh作为登录Shell的本地用户 列出这些用户的shadow密码记录 按每行”用户名 — 密码记录”保存结果 12345678910# 获取以bash/sh/zsh为shell用户列表users=$(awk -F&quot;:&quot; '$7~/(bash|sh|zsh)$/{print $1}' /etc/passwd)# 遍历用户列表for user in $usersdo # 过滤出对应用户的密码并输出 awk -F&quot;:&quot; -v usr=$user '$1==usr &amp;&amp; $2!=&quot;&quot; &amp;&amp; $2!=&quot;!!&quot; {printf &quot;%-12s %s\\n&quot;,usr,$2}END{}' /etc/shadowdone 2.统计网络连接信息中tcp和udp远程地址及对应的连接数 1)、实现命令 12345678910111213141516netstat -naptu | awk ' # 匹配以tcp或udp开头的行 $1~/(tcp|udp)/{ # $5字段为远程连接IP,使用:分隔,第1个为ip,第2个为端口 n=split($5,arr,&quot;:&quot;); # 判断切割后的数目是不是2 if(n==2){ # 将ip当做键进行自增 ips[arr[1]]++; } }END{ # 末尾的时候输出ip及对应出现的次数 printf &quot;%-12s 出现次数\\n&quot;,&quot;远程地址&quot;; for(ip in ips){ printf &quot;%-16s %-5s\\n&quot;,ip,ips[ip]}; }' 2)、运行结果","link":"/2022/03/20/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2-AWK-%E7%BB%83%E4%B9%A0/"},{"title":"文本三剑客-Sed-练习","text":"Sed—练习小练习1.修改当前主机名为kali.org 1sed &quot;s;$HOST;kali.org;&quot; /etc/hostname 2.修改hosts文件，添加两条映射记录 192.168.60.30 www.qq.com 192.168.60.60 www.baidu.com 1sed '$a 192.168.60.30 www.qq.com \\n192.168.60.60 www.baidu.com' /etc/hosts 综合练习练习1 题目给出了一个data.txt文件内容如下，根据题目写出对应答案 1234567891011121314151617181920212223242526272829Steve Blenheim:238-923-7366:95 Latham Lane, Easton, PA 83755:11/12/56:20300Betty Boop:245-836-8357:635 Cutesy Lane, Hollywood, CA ,91464:6/23/23:14500Igor Chevsky:385-375-8395:3567 Populus Place, Caldwell, NJ 23875:6/18/68:23400Norma Corder:397-857-2735:74 Pine Street, Dearborn, MI 23874:3/28/45:245700Jennifer Cowan:548-834-2348:583 Laurel Ave., Kingsville, TX 83745:10/1/35:58900Jon DeLoach:408-253-3122:123 Park St., San Jose, CA 04086:7/25/53:85100Karen Evich:284-758-2857:23 Edgecliff Place, Lincoln, NB 92086:7/25/53:85100Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200Fred Fardbarkle:674-843-1385:20 Parak Lane, DeLuth, MN 23850:4/12/23:780900Fred Fardbarkle:674-843-1385:20 Parak Lane, DeLuth, MN 23850:4/12/23:780900Lori Gortz:327-832-5728:3465 Mirlo Street, Peabody, MA 34756:10/2/65:35200Paco Gutierrez:835-365-1284:454 Easy Street, Decatur, IL 75732:2/28/53:123500Ephram Hardy:293-259-5395:235 CarltonLane, Joliet, IL 73858:8/12/20:56700James Ikeda:834-938-8376:23445 Aster Ave., Allentown, NJ 83745:12/1/38:45000Barbara Kertz:385-573-8326:832 Ponce Drive, Gary, IN 83756:12/1/46:268500Lesley Kirstin:408-456-1234:4 Harvard Square, Boston, MA 02133:4/22/62:52600William Kopf:846-836-2837:6937 Ware Road, Milton, PA 93756:9/21/46:43500Sir Lancelot:837-835-8257:474 Camelot Boulevard, Bath, WY 28356:5/13/69:24500Jesse Neal:408-233-8971:45 Rose Terrace, San Francisco, CA 92303:2/3/36:25000Zippy Pinhead:834-823-8319:2356 Bizarro Ave., Farmount, IL 84357:1/1/67:89500Arthur Putie:923-835-8745:23 Wimp Lane, Kensington, DL 38758:8/31/69:126000Popeye Sailor:156-454-3322:945 Bluto Street, Anywhere, USA 29358:3/19/35:22350Jose Santiago:385-898-8357:38 Fife Way, Abilene, TX 39673:1/5/58:95600Tommy Savage:408-724-0140:1222 Oxbow Court, Sunnyvale, CA 94087:5/19/66:34200Yukio Takeshida:387-827-1095:13 Uno Lane, Ashville, NC 23556:7/1/29:57000Vinh Tranh:438-910-7449:8235 Maple Street, Wilmington, VM 29085:9/23/63:68900 题目1：显示包含San的行 1sed -n '/San/p' data.txt 题目2：显示以J开头的人名所在的行 1sed -n '/^J/{=;p}' data.txt 题目3：显示700结尾的行 1sed -n '/700$/p' data.txt 题目4：显示不包834的行 1sed -n '/834/!p' data.txt 题目5：显示电话号码的区号为834的行 1sed -n '/:834/{=;p}' data.txt 题目6：显示这样的行:它包含一个大写字后跟四个小写字母,逗号,空格,和一个大写字母，并将逗号前面部分的字母用括号括起来 1sed -rn 's/([A-Z][a-z]{4})(,[[:space:]][A-Z])/[\\1]\\2/p' data.txt 题目7：显示以K或k开头的行 1sed -rn '/^[kK]/p' data.txt 题目8：显示工资为六位数的行 1sed -rn '/[^0][0-9]{6,}$/p' data.txt 题目9：显示包括Lincoln或lincoln的行 12sed -rn '/Lincoln|lincoln/p' data.txtsed -rn '/[lL]incoln/p' data.txt 题目10：把Jon的名字改成Jonathan 1sed -n 's#Jon#Jonathan#p' data.txt 题目11：删除文件头3行内容 1sed -n '{1,3d;p}' data.txt 题目12：显示5-10行 1sed -n '5,10{p;=}' data.txt 题目13：把三个星* * *添加到有Fred的行 1sed -rn 's/^Fred/***&amp;/p' data.txt 题目14：删除空白行 1sed -n '/^$/d' data.txt 练习2 1、题目需求： 找到使用bash或zsh或sh登录shell的本地用户 列出这些用户shadow的密码记录 按每行”用户名 —&gt; 密码记录”进行输出 2、效果如下图所示： 3、思路： 获取所有符合要求的用户，将它们变成数组的形式，方便后续操作 遍历用户数组从/etc/shadow文件中查询出对应的密码 输出当前遍历到的用户和查询到的密码 4、脚本内容如下： 1234567891011121314151617181920212223242526272829303132333435#!/bin/bash# 过滤出以sh,zsh,bash结束的用户,并在后面添加一个=,方便分割行users=$(sed -rn '/[z]?sh$|bash$/p' /etc/passwd | xargs -I {} echo '{}=')# 保存原来的分隔符号,并设置新的分隔符号为=OLD_IFS=&quot;$IFS&quot; &amp;&amp; IFS='='# 将查询出来的用户变成数组形式users=($users)# 遍历用户数组for line in ${users[@]}do # 取名用户名(%%表示后向匹配到最长的删除) name=${line%%:*} # 去掉用户名中的换行 name=`echo -n $name | tr -d &quot;\\n&quot;` # 查询出用户名对应的密码 prec=$(sed -n &quot;/${name}/p&quot; /etc/shadow) # 掐头:去掉开头用户名部分(#表示最顺序匹配去掉最短) pass=${prec#*:} # 去尾:去掉密码后面部分 pass=${pass%%:*} # 输出用户名和密码 echo -e &quot;$name --&gt; $pass&quot;done# 恢复原来的分隔符IFS=&quot;$OLD_IFS&quot; 5、运行结果 练习3 1、需求描述： 处理一个类似于Windows的ini配置文件中的文本，提取出配置项目及对应的条目数量 2、例如： 12345678910111213[init]dir=c:\\windows\\user=administratorarch=x64[running]task=12level=5[stop]clear_tmp_file=truebackground=falseauto_remove=true 3、输出结果是： 123init ---&gt; 3running ---&gt; 2stop ---&gt; 3 4、脚本内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/bash# 默认配置文件default_file=/etc/mysql/my.cnf# 判断是否传入参数且参数对应的文件是否存在if [ ! -z $1 ] &amp;&amp; [ -f $1 ];then FILE_NAME=$1else FILE_NAME=$default_filefi# 获取文件中的所有配置项function get_all_segment { sed -rn '/\\[.*\\]/{s#\\[##;s#\\]##p}' $FILE_NAME}# 获取配置项的数量function get_segment_count { # 取得配置项下的所有配置条目 items=$(sed -rn &quot;/$1/,/^\\[/p&quot; $FILE_NAME |egrep -v &quot;^#|^$|^\\[|^\\!&quot;) # 将分隔符号设置成换行 OLD_IFS=$IFS &amp;&amp; IFS=$'\\n' # 统计条目数量 count=0 for item in $items do let count++ done # 恢复换行 IFS=$OLD_IFS # 条目数 echo &quot;$count&quot;}function main { # 遍历文件中所有的配置项目 for segment in $(get_all_segment) do # 取出对应的条目 count=$(get_segment_count $segment) # 输出配置项目及对应的条目数 echo &quot;$segment ---&gt; $count&quot; done}# 调用main函数main 5、运行结果","link":"/2022/03/20/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2-Sed-%E7%BB%83%E4%B9%A0/"},{"title":"文本三剑客-Sed-详解","text":"文本三剑客—Sedsed工具概述Stream Editor，流式编辑器 非交互，基于模式匹配过滤及修改文本 逐行处理，并将结果输出到屏幕 可实现对文件的输出、删除、替换、复现、剪切、导入，导出等各种操作 命令格式解析主要用法 格式1：前置命令 | sed [选项] ‘编辑指令’ 举例：将单词首字母大写 1echo 'welcome to my home' | sed 's#\\w#\\u&amp;#' 格式2：sed [选项] ‘编辑指令’ 文件… 举例：读取/proc/meminfo中的第1行 1sed -n '1p' /proc/meminfo 常用参数选项 选项 作用 -n 屏蔽默认输出 -i 直接修改文件内容 -r 启用扩展的正则表达式，若与其它选项一起使用应作为首个选项 -e 可以指定多个处理动作 -f 编辑动作保存在文件中，指定文件执行，此方式为sed脚本方式 -{} 可能组合多个命令，以分号分隔 定址符 作用： 用来指定处理的起、止行数 省略定位符时，默认逐行处理全部文本 地址可表示为文本的”行号”，或者用来匹配的”/正则表达式/“ 匹配模式 含义 10command 匹配到第10行 10,20command 匹配从第10行开始，到第20行结束 10,+5cmmand 匹配从第10行开始，到第16行结束 /pattern1/command 匹配到pattern1的行 /pattern1/,/pattern2/command 匹配到pattern1的行开始，到匹配到pattern2的行结束 10,/pattern1/command 匹配从第10行开始，到匹配到pettern1的行结束 /pattern1/,10command 匹配到pattern’的行开始，到第10行匹配结束 处理命令 命令列表 类别 动作 含义 查询 p 打印 增加 a 行后追加 i 行前追加 r 外部文件读入,行后追加 w 匹配行写入外部文件 删除 d 删除 替换 s/old/new/g 将行内的old全部替换成new s/old/new/2g 将行内从第2个开始及以后old全部替换成new s/old/new/ig 将行内的old全部替换成new,忽略大小写 拓展： 替换操作的分享&quot;/&quot;可改用其它字符，如#、&amp;、!，便于修改文件路径 打印操作使用=可以输出行号，例如sed -n '/^mail/{=;p}' /etc/passwd 基本使用 拷贝/etc/hosts文件测试，利用sed以下任务 1.删除文件 中每行的第二个、最后一个字符 思路：第1次删掉第1个，第二次删掉第2个 1sed 's#.##2;s#.$##' hosts 2.删除文件中每行的第二个、最后一个单词 思路：分两次替换操作，第一次替换掉第2个单词，第二次替换掉最后一个单词 1sed -r 's#[a-Z]+##2;s#[a-Z]+([^a-Z]*)$#\\1#' hosts 3.将文件中每行的第一个、第二个字符互换 方法：每行文本拆分为”第1个字符”、”第2个字符”、”剩下的所有字符”三个部分，然后通过替换操作重排顺序为”2-1-3” 1sed -r 's;(.)(.)(.+);\\2\\1\\3;' hosts 4.将文件中每行的第一个、第二个单词互换 方法：每行文本拆分为”第1个单词”、”单词分隔”、”第2个单词”、”剩下的所有字符”四个部分，然后通过替换操作重排顺序为”3-2-1-4” 1sed -r 's#([a-Z]+)([^a-Z]*)([a-Z]+)(.*)#\\3\\2\\1\\4#' hosts 5.删除文件中所有的数字、行首的空格 方法：分两次替换，第1次替换数字，第2次替换空格 6.为文件中每个小写字母添加括号 方法：使用”&amp;”可调用s替换操作中的整个查找串 7.编辑一个sed脚本 将所有单词首字母大写 将所有空行删掉 在每一行后面添加换行 1.脚本内容 123s;([a-Z]+)([^a-Z]*);\\u\\1\\2;g/^$/d/[^\\S]/a\\\\ 2.运行脚本 1sed -r -f script.sed hosts shell中变量的引用1.匹配模式中存在变量，则建议使用双引号 1sed &quot;s/$old_str/$new_str&quot; 2.sed中需要引入自定义变量时，如果外面使用单引号，则自定义变量也必须使用单引号 1sed 's/'$old_str'/'$new_str'' 反向引用 &amp;和\\1：引用模式匹配到的整个串 例1：使用&amp;给/etc/passwd中的以r开头t结尾的4字母单词添加上括号 1sed 's/r..t/[&amp;]/g' /etc/passwd |head -1 例2：使用\\1给/etc/passwd中的以r开头t结尾的4字母单词添加上括号 1sed -r 's/(r..t)/&lt;*\\1*&gt;/g' /etc/passwd |head -1 上面两种方式实现了一样的功能，分别使用&amp;和\\1引用前面匹配到的字符串 两者区别在于： &amp;匹配到的是完整的字符串，只能引用整个字符串 \\1可以使用()对匹配的字符进行引用 例如：如果我们仅想替换匹配到的字符串的一部分，则必须使用\\1这种方式。 需求：现在想把sshd_config文件中的允许root登录改成不允许root登录 这里使用正则的反向引用来完成，将yes改成no 查询用法 命令对照表 命令 功能 1p 打印第1行内容 1,10p 打印1行到10行的内容 1,+5p 打印1行到6行的内容 /pattern1/p 打印每行中匹配到pattern1的行内容 /pattern1/,/pattern2/p 打印匹配到pattern1的行直到匹配到pattern2的所有行内容 /pattern1/,10p 打印匹配到pattern1的行到10行的所有行内容 10,/pattern1/p 打印第10行直到匹配到pattern1的所有行内容 练习举例 1.打印/etc/passwd中第20行的内容 1sed -n '20p' /etc/passwd 2.打印/etc/passwd从第6行开始，到第15行结束的内容 1sed -n '8,15p' /etc/passwd 3.打印/etc/passwd从第18行开始，然后+3行结束的内容 4.打印/etc/passwd中以内容为sys开头的行 5.打印/etc/passwd中以root开始的行，到开头为sys的行结束 6.打印/etc/passwd从24行开始，到行结尾含有nologin的内容结束 7.打印/etc/passwd中第一个以bash结尾的字符串开始，到第5行结束 注意了： 这里找到以bash结尾字符串的行是在第38行，我们给的条件是第5行结束 这里输出的结果只要38一行，所以得出结论，找到的行 &gt; 结束行，那么结束的行就等于找到的行 其它补充 示例 含义解析 sed -n ‘p’ msg.txt 输出所有行，等同于cat msg.txt sed -n ‘4p’ msg.txt 输出第4行 sed -n ‘4,7p msg.txt 输出第4~7行 sed -n ‘4,+10p’ msg.txt 输出第4行及其后的10行内容 sed -n ‘/^bin/p’ msg.txt 输出以bin开头的行 sed -n ‘p;n’ msg.txt 输出奇数行，n表示读入下一行文本(隔行) sed −n’n;p’ msg.txt 输出偶数行，n表示读入下一行文本（隔行） sed -n ‘10,${n;p}’ msg.txt 输出从第10行至文件末尾的所有偶数行 sed −n’$=’ msg.txt 输出文件的行数 删除内容 命令对照表 查询命令 含义 1d 删除第1行内容 1,10d 删除1行到10行的内容 1,+5d 删除1行到6行的内容 /pattern1/d 删除每行中匹配到pattern1的行内容 /pattern1/,/pattern2/d 删除匹配到pattern1的行直到匹配到pattern2的所有行内容 /pattern1/,10d 删除匹配到pattern1的行到10行的所有行内容 10,/pattern1/d 删除第10行直到匹配到pattern1的所有行内容 练习举例 1.删除/etc/passwd中第1行 1sed '1d' /etc/passwd 2.删除/etc/passwd中第6，21行的所有内容 1sed '6,21d' /etc/passwd 3.删除/etc/passwd中不是以bash或zsh内容结尾的用户 1sed -r '/bash$|zsh$/!d' /etc/passwd 4.删除/etc/passwd中以sys开头到以mail开头的行的所有内容 1sed '/^mail/,/^system/d' /etc/passwd 5.删除/etc/passwd中第1个不能登录的用户，直到15行的所有内容 1sed -r '/nologin|false/,15d' /etc/passwd 注意： 这个输出的结果和我们想的有差距，nick是在/etc/passwd文件中的最后一行 但是我们的条件是直到15行为止，它并没有到了15行就结束而是继续往下匹配 所以在实际的运用中不推荐这种方式，推荐下面这种数字在前表达式在后的方式 6.删除/etc/passwd中第3行到以sshd开头的所有行内容 1sed '3,/^sshd/d' /etc/passwd 7.删除/etc/passwd中以nobody开头的行到结尾行所有的内容 1sed '/^mail/,/$$/d' /etc/passwd 8.删除/etc/passwd中不能登录的所有用户 1sed -r '/nologin|false$/d' /etc/passwd 其它补充 命令 功能 sed ‘1,3n’ myfile 删除第3-5行 sed ‘/html/d’ myfile 删除所有包含html的行 sed ‘/html/!d’ myfile 不删除所有包含html的行 sed ‘/^#/d’ myfile 删除以#号开头的行 sed ‘$d’ myfile 删除最后一行 sed ‘/^$/d’ myfile 删除所有的空行 sed ‘/^$/{n;/^$/d}’ myfile 删除重复空行,连续两个空行只保留一个 替换用法 命令对照表 编辑命令 含义 1s/old/new/ 替换第1行内容old为new 1,10s/old/new/ 替换1行到10行的内容old为new 1,+5s/old/new/ 替换1行到6行的内容old为new /pattern1/s/old/new/ 替换匹配到pattern1的行内容old为new /pattern1/,/pattern2/s/old/new/ 替换匹配到pattern1的行直到匹配到pattern2的所有行内容old为new /pattern1/,10s/old/new/ 替换匹配到pattern1的行到10行的所有行内容old为new 10,/pattern1/s/oId/new/ 替换第10行直到匹配到pattern1的所有行内容old为new 练习举例s/old/new1.在行尾添内容 1echo &quot;hahalalayayaxixi&quot; | sed &quot;s/$/-wawawawaw/&quot; ​ 2.将所有的小写字母转成大写(\\u是把下一个字符转成大写upper) 1echo &quot;hello everyone&quot; | sed 's/[a-z]/\\u&amp;/g' 3.将所有的大写转换成小写(\\l是把下一个字符转成小写lower) 1echo &quot;HELLO SHENQI&quot;| sed 's/[A-Z]/\\l&amp;/g' 1s/old/new/11.将第一行第一个小写字符替换成大写字符 1echo &quot;how are your yayayay\\~\\~\\~&quot; |sed '1s/[a-z]/\\\\u&amp;/1' 3,6,s/old/new/2 **1.将.bashrc文件中第3行到第5行的第二个空格替换成* * * ** 1sed '3,6s/ /***/2' ~/.bashrc 2,+4s/old/new/3 1.将/etc/passwd文件中,从第2行开始往后数4行的第3个字母,用()括起来 1sed '2,+4s/[A-Za-z]/(&amp;)/3' /etc/passwd|head /pattern1/s/old/new/3gp 1.匹配/etc/passwd文件中以字母或者数字开头的行,并且长度大于等于10,并把它们第3位数字及以后的数字加上() 1sed -rn '/^[a-zA-Z0-9]{10,}/s/[0-9]/(&amp;)/3gp' /etc/passwd /pattern1/,/pattern2/s/old/new/g 1.匹配所有的if代码块，将里面的.替换成source 1sed -rn '/^if/,/^fi/s/ {1,}+\\./source/p' ~/.bashrc 15,/pattern1/s/old/new/ig1.从第15行开始匹配/etc/passwd文件中结尾是/usr/sbin/nologin的行并将它们全部替换成/bin/false 1sed -rn -e '15,/.+/{=;s#/usr/sbin/nologin$#/bin/false#p}' /etc/passwd 其它补充 示例 含义解析 sed ‘s/html/HTML/‘ tmp.txt 将每行中第一个html替换为HTML sed ‘s/html/HTML/3’ tmp.txt 将每行中的第3个html替换为HTML sed ‘s/html/HTML/g’ tmp.txt 将所有的html都替换为HTML sed ‘s/html//g’ tmp.txt 将所有的html都删除(替换的空串) sed ‘s/doc/&amp;s/g’ tmp.txt 将所有的doc都替换为docs，&amp;代表匹配到的串 sed ‘3,9s/^/#/‘ tmp.txt 将第3～9行注释掉(行首加#号) sed ‘s/^#sys/sys/‘ tmp.txt 解除以#sys开头的行的注释（去除行首的#号） 追加用法 命令 作用 a 在匹配行后面追加内容 i 在匹配行前追加内容 c 替换当前行 a—append1.复制passwd文件到家目录，在文件中第1,10行追加system user 12cp /etc/passwd ~/sed -i '1,10asystemuser' ~/passwd 2.在passwd文件中将所有以bash或zsh结尾的用户后追加login user 1sed -r '/(bash|zsh)$/a login user' ~/passwd i—insert1.将uname -a 的结果,插入到/etc/issue第1行。 12kernel=`uname –a`sed -i &quot;1i$kernel&quot; /etc/issue ​ 2.将echo $USER login 插入到家目录下的.bashrc文件中第1行 1sed -i '1iecho $USER login' \\~/.bashrc c—change 1.将sshd_config配置文件中PermitRootLogin设置成yes 1sed -ri '/#PermitRootLogin/c PermitRootLogin yes' /etc/ssh/sshd_config 导入导出基本动作 r 动作应结合-i选项才会存入，否则只输出 w 动作以覆盖的方式另存为新文件 命令 作用 r 将文件内容追加到匹配行后面 w 将匹配行写入指定文件 r—read 1. 读取/etc/fstab放到标准输出的第一行后面 此方法也是在文件中开头与结尾添加内容最快的方法 1echo -e &quot;#这是开机分区挂载文件\\n#以上就是分区内容&quot; |sed '1r /etc/fstab' 2.读取welcome.php文件中的内容,放到index.php的&lt;?php到最后一行之间 1sed '/&lt;?php/r welcome.php' index.php welcome.php文件内容 1echo &quot;&lt;h1&gt;这是我的第一个网页&lt;/h1&gt;&quot;; index.php文件内容 123&lt;?php phpinfo();?&gt; 执行结果 w-write1.匹配/etc/passwd以bash或zsh结尾的行，写到login_ok文件中 1sed -rn '/(bash|zsh)$/w login_ok' /etc/passwd 2.将/var/log/auth.log从第1行开始往后数9行放到top10.msg文件中 1sed -n '1,+9w top10.msg' /var/log/messages 复制剪切 模式空间 存放当前处理的行，将处理结果输出 若当前行不符合处理条件，则原样输 处理完当前行再读入下一行来处理 保持空间 作用类似于”剪贴板” 默认存放一个空行（换行符 \\n） 基本动作 H：模式空间——【追加】——&gt;保持空间 h：模式空间——【覆盖】——&gt;保持空间 G：保持空间——【追加】——&gt;模式空间 g：保持空间——【覆盖】——&gt;模式空间 小结：H/h——&gt;复制，G/g——&gt;粘贴 复制示例 1.将/etc/passwd前9行内容写到/tmp/pass文件中 1head -9 /etc/passwd &gt; /tmp/pass 2.将1到3行复现到文件结尾 1sed '1,3H;$G' /tmp/pass 命令执行后发现图中方框内存在一个空行，是因为保持空间里面默认就是一个空行 3.改用下列方式可避免出现空行 12# 原理就是将第1行覆盖到保持空间sed '1h;2,3H;$G' /tmp/pass 剪贴示例 1.将文件前3行剪切到文件结尾 1sed '1h;2,3H;1,3d;$G' /tmp/pass sed流控制 !取反操作 用途： 根据定址条件取反 示例 列出shell环境不是nologin和false的用户账号记录 n读下一行 用途 读入下一行进行处理（产生隔行/跳行的效果） 示例 分别列出文件的奇数/偶数行 1.输出奇数行 2.输出偶数行","link":"/2022/03/20/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2-Sed-%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"超兽武装","slug":"超兽武装","link":"/tags/%E8%B6%85%E5%85%BD%E6%AD%A6%E8%A3%85/"},{"name":"文本处理","slug":"文本处理","link":"/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"}],"categories":[{"name":"哲学","slug":"哲学","link":"/categories/%E5%93%B2%E5%AD%A6/"},{"name":"运维","slug":"运维","link":"/categories/%E8%BF%90%E7%BB%B4/"}]}